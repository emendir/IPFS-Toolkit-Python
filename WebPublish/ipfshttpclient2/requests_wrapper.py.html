<html>
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <link rel="stylesheet" href="https://rawgithub.com/highlightjs/cdn-release/master/build/styles/atom-one-dark.min.css">
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/highlight.min.js"></script>
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/languages/python.min.js"></script>
  <style>
    body {
      margin: 0px;
      padding: 15px;
      font-size: 12
    }
    .hljs {
      margin: -15px;
      word-wrap: break-word;
    }
    body, .hljs {
      font-family: Menlo, Consolas, DejaVu Sans Mono, monospace;
    }
    .number {
      float:left;
      text-align: right;
      display: inline-block;
      margin-right: 5px;
    }
    .ln {
      opacity: 0.5;
    }
    pre {
      tab-size:      4;
    }
  </style>
</head>
<body>
<pre><code class="py">
# type: ignore
&quot;&quot;&quot;Exposes the full &#x60;&#x60;requests&#x60;&#x60; HTTP library API, while adding an extra
&#x60;&#x60;family&#x60;&#x60; parameter to all HTTP request operations that may be used to restrict
the address family used when resolving a domain-name to an IP address.
&quot;&quot;&quot;
import socket
import urllib.parse

import requests
import requests.adapters
import urllib3
import urllib3.connection
import urllib3.exceptions
import urllib3.poolmanager
import urllib3.util.connection

AF2NAME = {
	int(socket.AF_INET):  &quot;ip4&quot;,
	int(socket.AF_INET6): &quot;ip6&quot;,
}
if hasattr(socket, &quot;AF_UNIX&quot;):
	AF2NAME[int(socket.AF_UNIX)] = &quot;unix&quot;
NAME2AF = {name: af for af, name in AF2NAME.items()}


# This function is copied from urllib3/util/connection.py (that in turn copied
# it from socket.py in the Python 2.7 standard library test suite) and accepts
# an extra &#x60;family&#x60; parameter that specifies the allowed address families for
# name resolution.
#
# The entire remainder of this file after this only exists to ensure that this
# &#x60;family&#x60; parameter is exposed all the way up to request&#x27;s &#x60;Session&#x60; interface,
# storing it as part of the URL scheme while traversing most of the layers.
def create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                      source_address=None, socket_options=None,
                      family=socket.AF_UNSPEC):
	host, port = address
	if host.startswith(&#x27;[&#x27;):
		host = host.strip(&#x27;[]&#x27;)
	err = None

	if not family or family == socket.AF_UNSPEC:
		family = urllib3.util.connection.allowed_gai_family()

	# Extension for Unix domain sockets
	if hasattr(socket, &quot;AF_UNIX&quot;) and family == socket.AF_UNIX:
		gai_result = [(socket.AF_UNIX, socket.SOCK_STREAM, 0, &quot;&quot;, host)]
	else:
		gai_result = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)

	for res in gai_result:
		af, socktype, proto, canonname, sa = res
		sock = None
		try:
			sock = socket.socket(af, socktype, proto)

			# If provided, set socket level options before connecting.
			if socket_options is not None and family != getattr(socket, &quot;AF_UNIX&quot;, NotImplemented):
				for opt in socket_options:
					sock.setsockopt(*opt)

			if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
				sock.settimeout(timeout)
			if source_address:
				sock.bind(source_address)
			sock.connect(sa)
			return sock
		except OSError as e:
			err = e
			if sock is not None:
				sock.close()
				sock = None

	if err is not None:
		raise err

	raise OSError(&quot;getaddrinfo returns an empty list&quot;)


# Override the &#x60;urllib3&#x60; low-level Connection objects that do the actual work
# of speaking HTTP
def _kw_scheme_to_family(kw, base_scheme):
	family = socket.AF_UNSPEC
	scheme = kw.pop(&quot;scheme&quot;, None)
	if isinstance(scheme, str):
		parts = scheme.rsplit(&quot;+&quot;, 1)
		if len(parts) == 2 and parts[0] == base_scheme:
			family = NAME2AF.get(parts[1], family)
	return family


class ConnectionOverrideMixin:
	def _new_conn(self):
		extra_kw = {
			&quot;family&quot;: self.family
		}
		if self.source_address:
			extra_kw[&#x27;source_address&#x27;] = self.source_address

		if self.socket_options:
			extra_kw[&#x27;socket_options&#x27;] = self.socket_options

		try:
			dns_host = getattr(self, &quot;_dns_host&quot;, self.host)
			if hasattr(socket, &quot;AF_UNIX&quot;) and extra_kw[&quot;family&quot;] == socket.AF_UNIX:
				dns_host = urllib.parse.unquote(dns_host)
			conn = create_connection(
				(dns_host, self.port), self.timeout, **extra_kw)
		except socket.timeout:
			raise urllib3.exceptions.ConnectTimeoutError(
				self, &quot;Connection to %s timed out. (connect timeout=%s)&quot; %
				(self.host, self.timeout))
		except OSError as e:
			raise urllib3.exceptions.NewConnectionError(
				self, &quot;Failed to establish a new connection: %s&quot; % e)

		return conn


class HTTPConnection(ConnectionOverrideMixin, urllib3.connection.HTTPConnection):
	def __init__(self, *args, **kw):
		self.family = _kw_scheme_to_family(kw, &quot;http&quot;)
		super().__init__(*args, **kw)


class HTTPSConnection(ConnectionOverrideMixin, urllib3.connection.HTTPSConnection):
	def __init__(self, *args, **kw):
		self.family = _kw_scheme_to_family(kw, &quot;https&quot;)
		super().__init__(*args, **kw)


# Override the higher-level &#x60;urllib3&#x60; ConnectionPool objects that instantiate
# one or more Connection objects and dispatch work between them
class HTTPConnectionPool(urllib3.HTTPConnectionPool):
	ConnectionCls = HTTPConnection


class HTTPSConnectionPool(urllib3.HTTPSConnectionPool):
	ConnectionCls = HTTPSConnection


# Override the highest-level &#x60;urllib3&#x60; PoolManager to also properly support the
# address family extended scheme values in URLs and pass these scheme values on
# to the individual ConnectionPool objects
class PoolManager(urllib3.PoolManager):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		
		# Additionally to adding our variant of the usual HTTP and HTTPS
		# pool classes, also add these for some variants of the default schemes
		# that are limited to some specific address family only
		self.pool_classes_by_scheme = {}
		for scheme, ConnectionPool in ((&quot;http&quot;, HTTPConnectionPool), (&quot;https&quot;, HTTPSConnectionPool)):
			self.pool_classes_by_scheme[scheme] = ConnectionPool
			for name in AF2NAME.values():
				self.pool_classes_by_scheme[&quot;{0}+{1}&quot;.format(scheme, name)] = ConnectionPool
				self.key_fn_by_scheme[&quot;{0}+{1}&quot;.format(scheme, name)] = self.key_fn_by_scheme[scheme]

	# These next two are only required to ensure that our custom &#x60;scheme&#x60; values
	# will be passed down to the &#x60;*ConnectionPool&#x60;s and finally to the actual
	# &#x60;*Connection&#x60;s as parameter
	def _new_pool(self, scheme, host, port, request_context=None):
		# Copied from &#x60;urllib3&#x60; to *not* surpress the &#x60;scheme&#x60; parameter
		pool_cls = self.pool_classes_by_scheme[scheme]
		if request_context is None:
			request_context = self.connection_pool_kw.copy()
		
		for key in (&#x27;host&#x27;, &#x27;port&#x27;):
			request_context.pop(key, None)
		
		if scheme == &quot;http&quot; or scheme.startswith(&quot;http+&quot;):
			for kw in urllib3.poolmanager.SSL_KEYWORDS:
				request_context.pop(kw, None)
		
		return pool_cls(host, port, **request_context)

	def connection_from_pool_key(self, pool_key, request_context=None):
		# Copied from &#x60;urllib3&#x60; so that we continue to ensure that this will
		# call &#x60;_new_pool&#x60;
		with self.pools.lock:
			pool = self.pools.get(pool_key)
			if pool:
				return pool

			scheme = request_context[&#x27;scheme&#x27;]
			host = request_context[&#x27;host&#x27;]
			port = request_context[&#x27;port&#x27;]
			pool = self._new_pool(scheme, host, port, request_context=request_context)
			self.pools[pool_key] = pool
		return pool


# Override the lower-level &#x60;requests&#x60; adapter that invokes the &#x60;urllib3&#x60;
# PoolManager objects
class HTTPAdapter(requests.adapters.HTTPAdapter):
	def init_poolmanager(self, connections, maxsize, block=False, **pool_kwargs):
		# save these values for pickling (copied from &#x60;requests&#x60;)
		self._pool_connections = connections
		self._pool_maxsize = maxsize
		self._pool_block = block

		self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,
		                               block=block, strict=True, **pool_kwargs)


# Override the highest-level &#x60;requests&#x60; Session object to accept the &#x60;family&#x60;
# parameter for any request and encode its value as part of the URL scheme
# when passing it down to the adapter
class Session(requests.Session):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.family = socket.AF_UNSPEC

		# Additionally to mounting our variant of the usual HTTP and HTTPS
		# adapter, also mount it for some variants of the default schemes that
		# are limited to some specific address family only
		adapter = HTTPAdapter()
		for scheme in (&quot;http&quot;, &quot;https&quot;):
			self.mount(&quot;{0}://&quot;.format(scheme), adapter)
			for name in AF2NAME.values():
				self.mount(&quot;{0}+{1}://&quot;.format(scheme, name), adapter)

	def request(self, method, url, *args, **kwargs):
		family = kwargs.pop(&quot;family&quot;, self.family)
		if family != socket.AF_UNSPEC:
			# Inject provided address family value as extension to scheme
			url = urllib.parse.urlparse(url)
			url = url._replace(scheme=&quot;{0}+{1}&quot;.format(url.scheme, AF2NAME[int(family)]))
			url = url.geturl()
		return super().request(method, url, *args, **kwargs)


session = Session


# Import other &#x60;requests&#x60; stuff to make the top-level API of this more compatible
from requests import (
	__title__, __description__, __url__, __version__, __build__, __author__,
	__author_email__, __license__, __copyright__, __cake__,
	
	exceptions, utils, packages, codes,
	Request, Response, PreparedRequest,
	RequestException, Timeout, URLRequired, TooManyRedirects, HTTPError,
	ConnectionError, FileModeWarning, ConnectTimeout, ReadTimeout
)


# Re-implement the top-level “session-less” API
def request(method, url, **kwargs):
	with Session() as session:
		return session.request(method=method, url=url, **kwargs)


def get(url, params=None, **kwargs):
	kwargs.setdefault(&#x27;allow_redirects&#x27;, True)
	return request(&#x27;get&#x27;, url, params=params, **kwargs)


def options(url, **kwargs):
	kwargs.setdefault(&#x27;allow_redirects&#x27;, True)
	return request(&#x27;options&#x27;, url, **kwargs)


def head(url, **kwargs):
	kwargs.setdefault(&#x27;allow_redirects&#x27;, False)
	return request(&#x27;head&#x27;, url, **kwargs)


def post(url, data=None, json=None, **kwargs):
	return request(&#x27;post&#x27;, url, data=data, json=json, **kwargs)


def put(url, data=None, **kwargs):
	return request(&#x27;put&#x27;, url, data=data, **kwargs)


def patch(url, data=None, **kwargs):
	return request(&#x27;patch&#x27;, url, data=data, **kwargs)


def delete(url, **kwargs):
	return request(&#x27;delete&#x27;, url, **kwargs)

</code></pre>
<script>hljs.initHighlightingOnLoad();</script>
<script>
  setTimeout(function() {
    $(".number").css("width", "20px");
    $(".number span").attr("class", "ln hljs-subst");
    resize();
    var timer = false;
    $(window).resize(function() {
      if (timer !== false) {
        clearTimeout(timer);
      }
      timer = setTimeout(function() {
        resize();
      }, 200);
    })

  }, 100);
  function resize() {
    $("span.code").each(function(i, c) {
      var h = $(c).height();
      $(c).prev().height(h);
    });
  }
</script>
</body>
</html>