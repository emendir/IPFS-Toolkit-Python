<html>
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <link rel="stylesheet" href="https://rawgithub.com/highlightjs/cdn-release/master/build/styles/atom-one-dark.min.css">
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/highlight.min.js"></script>
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/languages/python.min.js"></script>
  <style>
    body {
      margin: 0px;
      padding: 15px;
      font-size: 12
    }
    .hljs {
      margin: -15px;
      word-wrap: break-word;
    }
    body, .hljs {
      font-family: Menlo, Consolas, DejaVu Sans Mono, monospace;
    }
    .number {
      float:left;
      text-align: right;
      display: inline-block;
      margin-right: 5px;
    }
    .ln {
      opacity: 0.5;
    }
    pre {
      tab-size:      4;
    }
  </style>
</head>
<body>
<pre><code class="py">
## This is a wrapper for the ipfshttpclient module to make it easier to interact with the Interplanetary File System (IPFS)
## process running on the computer.
## To use it you must have IPFS running on your computer.
## This wrapper uses a custom updated version of the ipfshttpclient.


import sys
from subprocess import Popen, PIPE
import subprocess
import _thread
import os
import os.path
import threading
import base64
import ipfshttpclient2 as ipfshttpclient
import multiprocessing
import traceback
import IPFS_LNS

print_log = False

autostart = True
started = False
ipfs = ipfshttpclient.client.Client()
subscriptions = list([])    # List for keeping track of subscriptions to IPFS topics, so that subscriptions can be ended

def Start():
    try:
        global started
        ipfs = ipfshttpclient.connect(&#x27;/ip4/127.0.0.1/tcp/5001/http&#x27;)
        started = True
        return True
    except Exception as e:
        if print_log:
            print(&quot;&quot;)
            print(&quot;----------------------------------------------------&quot;)
            traceback.print_exc() # printing stack trace
            print(&quot;----------------------------------------------------&quot;)
            print(&quot;&quot;)
            print(type(e))
            if(str(e).startswith(&quot;ConnectionError: HTTPConnectionPool&quot;)):
                print(&quot;Failed to connect to the IPFS process on this machine.&quot;)
                print(&quot;Is IPFS running?&quot;)
                print(&quot;Is it listening on &#x27;/ip4/127.0.0.1/tcp/5001/http&#x27;?&quot;)
                return &quot;IPFS not running&quot;



# Publishes the input text to specified the IPFS PubSub topic
def PublishToTopic(topic, text):
    ipfs.pubsub.publish(topic, text)

# Listens to the specified IPFS PubSub topic and passes received text to the input eventhandler function
def SubscribeToTopic(topic, eventhandler):
    def Listen():
        sub = ipfs.pubsub.subscribe(topic)
        with ipfs.pubsub.subscribe(topic) as sub:
            for text in sub:
                _thread.start_new_thread(eventhandler, (str(base64.b64decode(str(text).split(&#x27;\&#x27;&#x27;)[7]), &quot;utf-8&quot;),))
    #thread =  multiprocessing.Process(target = Listen, args= ())
    #thread.start()
    _thread.start_new_thread(Listen, ())
    #subscriptions.append((topic, eventhandler, thread))
    #return thread

def UnSubscribeFromTopic(topic, eventhandler):
    index = 0
    for subscription in subscriptions:
        if(subscription[0] == topic and subscription[1] == eventhandler):
            subscription[2].terminate()
            break
        index = index + 1
    subscriptions.pop(index)    # remove the subscription from the list of subscriptions


# publishes the input file on IPFS and returns the newly published file&#x27;s ID
def PublishFile(path):
    output = ipfs.add(path)
    return str(output).split(&quot;\&#x27;&quot;)[7] # extracting the file ID from the process&#x27; output

def UploadFile(filename:str):
    &quot;&quot;&quot;
    Upload a file to IPFS. Does not work for directories.
    &quot;&quot;&quot;
    return ipfs.add(filename).get(&quot;Hash&quot;)

def Upload(path:str):
    &quot;&quot;&quot;
    Upload a file or a directory to IPFS.
    Returns the Hash of the uploaded file.
    &quot;&quot;&quot;
    result = ipfs.add(path, recursive=True)
    if(type(result)==list):
        return result[-1].get(&quot;Hash&quot;)
    else:
        return result.get(&quot;Hash&quot;)
# Downloads the file with the specified ID and saves it with the specified path
def DownloadFile(ID, path = &quot;&quot;):
    data = ipfs.cat(ID)
    if path != &quot;&quot;:
        file = open(path, &quot;wb&quot;)
        file.write(data)
        file.close()
    return data

def CatFile(ID):
    return ipfs.cat(ID)

def CreateIPNS_Record(name:str):
    result = ipfs.key.gen(key_name=name, type=&quot;rsa&quot;)
    print(result)
    if(type(result)==list):
        return result[-1].get(&quot;Id&quot;)
    else:
        return result.get(&quot;Id&quot;)
def UpdateIPNS_RecordFromHash(name:str, id:str):
    ipfs.name.publish(ipfs_path=id, key=name)
def UpdateIPNS_Record(name:str, path):
    id = UploadFile(path)
    UpdateIPNS_RecordFromHash(name, id)

def DownloadIPNS_Record(name, path=&quot;&quot;):
    return DownloadFile(ResolveIPNS_Key(name), path)

def ResolveIPNS_Key(ipns_id):
    return ipfs.name.resolve(name=ipns_id).get(&quot;Path&quot;)

def CatIPNS_Record(name):
    ipfs_path = ipfs.name.resolve(name=name).get(&quot;Path&quot;)
    return CatFile(ipfs_path)

# Returns a list of the multiaddresses of all connected peers
def ListPeerMaddresses():
    proc = Popen([&#x27;ipfs&#x27;, &#x27;swarm&#x27;, &#x27;peers&#x27;], stdout=PIPE)
    proc.wait()
    peers = []
    for line in proc.stdout:
        peers.append(line.decode(&#x27;utf-8&#x27;))

    return peers

# Returns the multiaddresses of input the peer ID
def FindPeer(ID :str):
    try:
        response = ipfs.dht.findpeer(ID)
        if(len(response.get(&quot;Responses&quot;)[0].get(&quot;Addrs&quot;))&gt; 0):
            return response
    except:
        return None




# Returns the IPFS ID of the currently running IPFS node
def MyID():
    return ipfs.id().get(&quot;ID&quot;)
myid = MyID

def ListenOnPortTCP(protocol, port):
    ipfs.p2p.listen(&quot;/x/&quot; + protocol, &quot;/ip4/127.0.0.1/tcp/&quot; + str(port))
listenonportTCP = ListenOnPortTCP
ListenTCP = ListenOnPortTCP
listentcp = ListenOnPortTCP
def ListenOnPort(protocol, port):
    ipfs.p2p.listen(&quot;/x/&quot; + protocol, &quot;/ip4/127.0.0.1/udp/&quot; + str(port))
listenonportUDP = ListenOnPort
ListenUDP = ListenOnPort
listenudp = ListenOnPort
listenonport = ListenOnPort
Listen = ListenOnPort
listen = ListenOnPort

def ForwardFromPortToPeer(protocol:str, port, peerID):
    ipfs.p2p.forward(&quot;/x/&quot; + protocol, &quot;/ip4/127.0.0.1/tcp/&quot; + str(port), &quot;/p2p/&quot; + peerID)

def ClosePortForwarding(all: bool = False, protocol: str = None, listenaddress: str = None, targetaddress: str = None):
    ipfs.p2p.close(all, protocol, listenaddress, targetaddress)

def CheckPeerConnection(id, name = &quot;&quot;):
    &quot;&quot;&quot;
    Tries to connect to the specified peer, and stores its multiaddresses in IPFS_LNS.
    Paramaters:
        id: the IPFS PeerID or the IPFS_LNS name  of the computer to connect to
        name: (optional) the human readable name of the computer to connect to (not critical, you can put in whatever you like)&quot;&quot;&quot;
    contact = IPFS_LNS.GetContact(id)
    if not contact:
        contact = IPFS_LNS.AddContact(id, name)
    return contact.CheckConnection()


if autostart:
    Start()

</code></pre>
<script>hljs.initHighlightingOnLoad();</script>
<script>
  setTimeout(function() {
    $(".number").css("width", "20px");
    $(".number span").attr("class", "ln hljs-subst");
    resize();
    var timer = false;
    $(window).resize(function() {
      if (timer !== false) {
        clearTimeout(timer);
      }
      timer = setTimeout(function() {
        resize();
      }, 200);
    })

  }, 100);
  function resize() {
    $("span.code").each(function(i, c) {
      var h = $(c).height();
      $(c).prev().height(h);
    });
  }
</script>
</body>
</html>