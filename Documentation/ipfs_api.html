<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>ipfs_api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{color:#ddd;background:#111;--highlight-color:#050}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #222;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#f33}pre code{color:#ddd;background:#080808;font-size:.8em;line-height:1.4em}code{color:#ddd;background:#141414;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{color:#ddd;background:#080808;border:0;border-top:1px solid #555;border-bottom:1px solid #555;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #222}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{color:#ddd;background:#181818;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{color:#ddd;background:#181818}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#666;border-left:5px solid #181818;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#999;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{color:#ddd;background:#202}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #222}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#fff !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #666;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ipfs_api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This is a wrapper for the ipfshttpclient module to make it easier to interact with the Interplanetary File System (IPFS)
# process running on the computer.
# To use it you must have IPFS running on your computer.
# This wrapper uses a custom updated version of the ipfshttpclient.

from io import BytesIO
from threading import Thread
import logging
import ipfs_lns
import traceback
import os.path
import os
from subprocess import Popen, PIPE
import tempfile
import shutil
from threading import Event
import time
from termcolor import colored
from datetime import timedelta
from datetime import datetime
# import sys
# import subprocess
# import threading
# import multiprocessing
try:
    import base64
    import ipfshttpclient2 as ipfshttpclient
    from base64 import urlsafe_b64decode, urlsafe_b64encode
    http_client = ipfshttpclient.client.Client()
    LIBERROR = False
except Exception as e:
    import traceback
    traceback.print_exc()
    LIBERROR = True
    http_client = None
    ipfshttpclient = None
print_log = False

# List for keeping track of subscriptions to IPFS topics, so that subscriptions can be ended
subscriptions = list([])


def publish(path: str):
    &#34;&#34;&#34;Upload a file or a directory to IPFS, returning its CID.
    Args:
        path (str): the path of the file or directroy to publish
    Returns:
        str: the IPFS content ID (CID) of the published file/directory
    &#34;&#34;&#34;
    result = http_client.add(path, recursive=True)
    if (type(result) == list):
        return result[-1][&#34;Hash&#34;]
    else:
        return result[&#34;Hash&#34;]


def predict_cid(path: str):
    &#34;&#34;&#34;Get the CID a file or directory would have if it were to be published on
    IPFS, without actually publishing it.
    Args:
        path (str): the path of the file or directroy to publish
    Returns:
        str: the IPFS content ID (CID) the file/directory would have
                if published
    &#34;&#34;&#34;
    result = http_client.add(path, recursive=True, only_hash=True)
    if (type(result) == list):
        return result[-1][&#34;Hash&#34;]
    else:
        return result[&#34;Hash&#34;]


def download(cid, path=&#34;.&#34;):
    &#34;&#34;&#34;Get the specified IPFS content, saving it to a file.
    Args:
        cid (str): the IPFS content ID (cid) of the resource to get
        path (str): (optional) the path (directory or filepath) of the saved file
    &#34;&#34;&#34;

    # create temporary download directory
    tempdir = tempfile.mkdtemp()

    # download and save file/folder to temporary directory
    http_client.get(cid=cid, target=tempdir)

    # move file/folder from temporary directory to desired path
    shutil.move(os.path.join(tempdir, cid), path)

    # cleanup temporary directory
    shutil.rmtree(tempdir)


def read(cid):
    &#34;&#34;&#34;Returns the textual content of the specified IPFS resource.
    Args:
        cid (str): the IPFS content ID (CID) of the resource to read
    Returns:
        str: the content of the specified IPFS resource as text
    &#34;&#34;&#34;
    return http_client.cat(cid)


def pin(cid: str):
    &#34;&#34;&#34;Ensure the specified IPFS resource remains available on this IPFS node.
    Args:
        cid (str): the IPFS content ID (CID) of the resource to pin
    &#34;&#34;&#34;
    http_client.pin.add(cid)


def unpin(cid: str):
    &#34;&#34;&#34;Allow a pinned IPFS resource to be garbage-collected and removed on this IPFS node.
    Args:
        cid (str): the IPFS content ID (CID) of the resource to unpin
    &#34;&#34;&#34;
    http_client.pin.rm(cid)


def remove(cid: str):
    &#34;&#34;&#34;Remove content with the given CID from this IPFS node&#39;s storage.
    Note: removes all unpinned content from this IPFS node&#39;s storage.
    Args:
        cid (str): the IPFS content ID (CID) of the resource to unpin
    &#34;&#34;&#34;
    unpin(cid)
    http_client.repo.gc()


__pins_cache = {}


def pins(cids_only: bool = False, cache_age_s: int = None):
    &#34;&#34;&#34;Get the CIDs of files we have pinned on IPFS
    Args:
        cids_only (bool): if True, returns a plain list of IPFS CIDs
            otherwise, returns a list of dicts of CIDs and their pinning type
        cache_age_s (int): getting the of pins from IPFS can take several
            seconds. IPFS_API therefore caches each result. If the age of the
            cache is less than this parameter, the cacheed result is returned,
            otherwise the slow process of getting the latest list of pins is
            used.
    Returns:
        list(): a list of the CIDs of pinned objects. The list element type
            depends on the cids_only parameter (see above)
    &#34;&#34;&#34;
    global __pins_cache
    if __pins_cache and cache_age_s and (datetime.utcnow() - __pins_cache[&#39;date&#39;]).total_seconds() &lt; cache_age_s:
        data = __pins_cache[&#39;data&#39;]
    else:
        data = http_client.pin.ls()[&#39;Keys&#39;].as_json()
        __pins_cache = {
            &#34;date&#34;: datetime.utcnow(),
            &#34;data&#34;: data
        }
    if cids_only:
        return list(data.keys())
    else:
        return data


def create_ipns_record(name: str, type: str = &#34;rsa&#34;, size: int = 2048):
    &#34;&#34;&#34;Create an IPNS record (eqv. IPNS key).
    Args:
        name (str): the name of the record/key (in the scope of this IPFS node)
        type (str): the cryptographic algorithm behind this key&#39;s security
        size (int): the length of the key
    &#34;&#34;&#34;
    result = http_client.key.gen(key_name=name, type=type, size=size)
    if isinstance(result, list):
        return result[-1][&#34;Id&#34;]
    else:
        return result[&#34;Id&#34;]


def update_ipns_record_from_cid(record_name: str, cid: str, ttl: str = &#34;24h&#34;, lifetime: str = &#34;24h&#34;, ** kwargs: ipfshttpclient.client.base.CommonArgs):
    &#34;&#34;&#34;Assign IPFS content to an IPNS record.
    Args:
        record_name (str): the name of the IPNS record (IPNS key) to be updated
        cid (str): the IPFS content ID (CID) of the content to assign to the IPNS record
        ttl (str): Time duration this record should be cached for.
                                Uses the same syntax as the lifetime option.
                                (caution: experimental).
        lifetime (str): Time duration that the record will be valid for.
                                Default: 24h.
    &#34;&#34;&#34;
    http_client.name.publish(ipfs_path=cid, key=record_name,
                             ttl=ttl, lifetime=lifetime, ** kwargs)


def update_ipns_record(name: str, path, ttl: str = &#34;24h&#34;, lifetime: str = &#34;24h&#34;):
    &#34;&#34;&#34;Publish a file to IPFS and assign it to an IPNS record.
    Args:
        record_name (str): the name of the IPNS record (IPNS key) to be updated
        path (str): the path of the file to assign to the IPNS record
        ttl (str): Time duration this record should be cached for.
                                Uses the same syntax as the lifetime option.
                                (caution: experimental).
        lifetime (str): Time duration that the record will be valid for.
                                Default: 24h.
    &#34;&#34;&#34;
    cid = publish(path)
    update_ipns_record_from_cid(name, cid, ttl=ttl, lifetime=lifetime)
    return cid


def resolve_ipns_key(ipns_key, nocache=False):
    &#34;&#34;&#34;Get the IPFS CID of the given IPNS record (IPNS key)
    Args:
        ipns_key: the key of the IPNS record to lookup
        nocache: whether or not to ignore this IPFS nodes cached memory of IPNS keys
    Returns:
        str: the IPFS CID associated with the IPNS key
    &#34;&#34;&#34;
    return http_client.name.resolve(name=ipns_key, nocache=nocache)[&#34;Path&#34;]


def download_ipns_record(ipns_key, path=&#34;&#34;, nocache=False):
    &#34;&#34;&#34;Get the specified IPFS content, saving it to a file.
    Args:
        ipns_key (str): the key of the IPNS record to get
        path (str): (optional) the path (directory or filepath) of the saved file
        nocache: whether or not to ignore this IPFS nodes cached memory of IPNS keys
    &#34;&#34;&#34;
    return download(resolve_ipns_key(ipns_key, nocache=nocache), path)


def read_ipns_record(ipns_key, nocache=False):
    &#34;&#34;&#34;Returns the textual content of the specified IPFS resource.
    Args:
        ipns_key (str): the key of the IPNS record to read
    Returns:
        str: the content of the specified IPFS resource as text
    &#34;&#34;&#34;
    return read(resolve_ipns_key(ipns_key, nocache=nocache))


def get_ipns_record_validity(ipns_key):
    &#34;&#34;&#34;Gets the time at which the given IPNS record expires.

    Args:
        ipns_key (str): the key of the IPNS record to look up

    Returns:
        datetime: the time at which the given IPNS record expires
    &#34;&#34;&#34;
    if not ipns_key.startswith(&#39;/ipns/&#39;):
        ipns_key = f&#34;/ipns/{ipns_key}&#34;
    tempdir = tempfile.mkdtemp()
    record_filepath = os.path.join(tempdir, &#34;ipns_record&#34;)
    http_client.routing.get(
        ipns_key,
        record_filepath
    )
    response = http_client.name.inspect(record_filepath)
    timestamp = response[&#39;Entry&#39;][&#39;Validity&#39;]

    shutil.rmtree(tempdir)
    return datetime.fromisoformat(timestamp[:-1])


def my_id():
    &#34;&#34;&#34;Returns this IPFS node&#39;s peer ID.
    Returns:
        str: the peer ID of this node
    &#34;&#34;&#34;
    return http_client.id()[&#34;ID&#34;]


def is_ipfs_running():
    &#34;&#34;&#34;Checks whether or not the IPFS daemon is currently running.
    Returns:
        bool: whether or not the IPFS daemon is currently running
    &#34;&#34;&#34;
    return len(my_multiaddrs()) &gt; 0


def my_multiaddrs():
    &#34;&#34;&#34;Returns this IPFS node&#39;s peer ID.
    Returns:
        str: the peer ID of this node
    &#34;&#34;&#34;
    return http_client.id()[&#34;Addresses&#34;]


def list_peers():
    &#34;&#34;&#34;Returns a list of the IPFS multiaddresses of the other nodes
    this node is connected to.
    Returns:
        list(str): a list of the IPFS multiaddresses of the other nodes
        this node is connected to
    &#34;&#34;&#34;
    proc = Popen([&#39;ipfs&#39;, &#39;swarm&#39;, &#39;peers&#39;], stdout=PIPE)
    proc.wait()
    peers = []
    for line in proc.stdout:
        peers.append(line.decode(&#39;utf-8&#39;).strip(&#34;\n&#34;))

    return peers


def list_peer_multiaddrs():
    print(colored(&#34;IPFS_API: DEPRECATED: This function (ifps_api.list_peer_multiaddrs) has been renamed to ipfs_api.list_peers to avoid confusion with the new get_peer_multiaddrs function.&#34;, &#34;yellow&#34;))
    return list_peers()


def get_peer_multiaddrs(peer_id):
    &#34;&#34;&#34;Returns the multiaddresses (without the IPFS CID) via which we can reach
    the specified peer.
    Append /p2p/PEER_ID to these multiaddress parts to turn them into complete
    multiaddresses.

    Args:
        peer_id (str): the IPFS ID of the peer to lookup

    Returns:
        list(str): the multiaddresses (without the IPFS CID) via which we can
        reach the given peer
    &#34;&#34;&#34;
    try:
        response = http_client.routing.findpeer(peer_id)
        return response[&#34;Responses&#34;][0][&#34;Addrs&#34;]
    except:
        return []


def connect_to_peer(multiaddr):
    &#34;&#34;&#34;Tries to connect to a peer given its multiaddress.
    Returns:
        bool: success
    &#34;&#34;&#34;
    try:
        response = http_client.swarm.connect(multiaddr)
        if response[&#34;Strings&#34;][0][-7:] == &#34;success&#34;:
            return True
        return False
    except:
        return False


def find_peer(peer_id: str):
    &#34;&#34;&#34;Try to connect to the specified IPFS node.
    Args:
        peer_id (str): the IPFS peer ID of the node to connect to
    Returns:
        str: the multiaddress of the connected node
    &#34;&#34;&#34;
    try:
        response = http_client.routing.findpeer(peer_id)
        if (len(response[&#34;Responses&#34;][0][&#34;Addrs&#34;]) &gt; 0):
            return response
    except:
        return None


def is_peer_connected(peer_id, ping_count=1):
    &#34;&#34;&#34;Tests the connection to the given IPFS peer.
    Args:
        peer_id (str): the IPFS ID of the peer to test
        count (int): (optional, default 1) the number of pings to send
    Returns:
        bool: whether or not the peer is connected
    &#34;&#34;&#34;
    responses = http_client.ping(peer_id, count=ping_count)
    return responses[-1][&#39;Success&#39;]


def find_providers(cid):
    &#34;&#34;&#34;Lookup/find out which IPFS nodes provide the file with the given CID
    (including onesself).
    E.g. to check if this computer hosts a file with a certain CID:
    def DoWeHaveFile(cid:str):
        ipfs_api.my_id() in ipfs_api.find_providers(cid)
    Args:
        cid (str): cid (str): the IPFS content ID (CID) of the resource to look up
    Returns:
        list: the peer IDs of the IPFS nodes who provide the file
    &#34;&#34;&#34;
    responses = http_client.routing.findprovs(cid)
    peers = []
    for response in responses:
        if not isinstance(response, ipfshttpclient.client.base.ResponseBase):
            continue
        if response[&#39;Type&#39;] == 4:
            for resp in response[&#39;Responses&#39;]:
                if resp[&#39;ID&#39;] and resp[&#39;ID&#39;] not in peers:
                    peers.append(resp[&#39;ID&#39;])
    return peers


def create_tcp_listening_connection(name: str, port: int):
    &#34;&#34;&#34;Open a listener TCP connection for IPFS&#39; libp2p stream-mounting (port-forwarding).
    TCP traffic coming from another peer via this connection is forwarded
    to the specified port on localhost.
    Args:
        name (str): the name of the connection (starts with /x/)
        port (int): the local TCP port number to forward incoming traffic to
    &#34;&#34;&#34;
    if name[:3] != &#34;/x/&#34;:
        name = &#34;/x/&#34; + name
    http_client.p2p.listen(name, &#34;/ip4/127.0.0.1/tcp/&#34; + str(port))


def create_tcp_sending_connection(name: str, port, peerID):
    &#34;&#34;&#34;Open a sending TCP connection for IPFS&#39; libp2p stream-mounting (port-forwarding).
    TCP traffic sent to the specified port on localhost will be fowarded
    to the specified peer via this connection.
    Args:
        name (str): the name of the connection (starts with /x/)
        port (int): the local TCP port number from which to forward traffic
    &#34;&#34;&#34;
    if name[:3] != &#34;/x/&#34;:
        name = &#34;/x/&#34; + name
    http_client.p2p.forward(name, &#34;/ip4/127.0.0.1/tcp/&#34;
                            + str(port), &#34;/p2p/&#34; + peerID)


def close_all_tcp_connections(listeners_only=False):
    &#34;&#34;&#34;Close all libp2p stream-mounting (IPFS port-forwarding) connections.
    Args:
        listeners_only (bool): if set to True, only listening connections are closed
    &#34;&#34;&#34;
    if listeners_only:
        http_client.p2p.close(listenaddress=&#34;/p2p/&#34; + my_id())
    else:
        http_client.p2p.close(True)


def close_tcp_sending_connection(name: str = None, port: str = None, peer_id: str = None):
    &#34;&#34;&#34;Close specific sending libp2p stream-mounting (IPFS port-forwarding) connections.
    Args:
        name (str): the name of the connection to close
        port (str): the local forwarded TCP port of the connection to close
        peer_id (str): the target peer_id of the connection to close
    &#34;&#34;&#34;
    if name and name[:3] != &#34;/x/&#34;:
        name = &#34;/x/&#34; + name
    if port and isinstance(port, int):
        listenaddress = f&#34;/ip4/127.0.0.1/tcp/{port}&#34;
    else:
        listenaddress = port
    if peer_id and peer_id[:5] != &#34;/p2p/&#34;:
        targetaddress = &#34;/p2p/&#34; + peer_id
    else:
        targetaddress = peer_id
    http_client.p2p.close(False, name, listenaddress, targetaddress)


def close_tcp_listening_connection(name: str = None, port: str = None):
    &#34;&#34;&#34;Close specific listening libp2p stream-mounting (IPFS port-forwarding) connections.
    Args:
        name (str): the name of the connection to close
        port (str): the local listening TCP port of the connection to close
    &#34;&#34;&#34;
    if name and name[:3] != &#34;/x/&#34;:
        name = &#34;/x/&#34; + name
    if port and isinstance(port, int):
        targetaddress = f&#34;/ip4/127.0.0.1/tcp/{port}&#34;
    else:
        targetaddress = port
    http_client.p2p.close(False, name, None, targetaddress)


def check_peer_connection(id, name=&#34;&#34;):
    &#34;&#34;&#34;Try to connect to the specified peer, and stores its multiaddresses in ipfs_lns.
    Args:
        id (str): the IPFS PeerID or the ipfs_lns name  of the computer to connect to
        name (str): (optional) the human readable name of the computer to connect to (not critical, you can put in whatever you like)&#34;&#34;&#34;
    contact = ipfs_lns.get_contact(id)
    if not contact:
        contact = ipfs_lns.add_contact(id, name)
    return contact.check_connection()


class PubsubListener():
    &#34;&#34;&#34;Listener object for PubSub subscriptions.&#34;&#34;&#34;
    _terminate = False
    __listening = False
    sub = None
    _REFRESH_RATE = 5  # seconds. How often the pubsub HTTP listener ist restarted, also the maximum duration termination can take

    def __init__(self, topic, eventhandler):
        self.topic = topic
        self.eventhandler = eventhandler
        self.listen()

    def _listen(self):
        if self.__listening:
            return
        self.__listening = True
        &#34;&#34;&#34;blocks the calling thread&#34;&#34;&#34;
        while not self._terminate:
            try:
                if int(http_client.version()[&#34;Version&#34;].split(&#34;.&#34;)[1]) &gt;= 11:
                    with http_client.pubsub.subscribe(self.topic, timeout=self._REFRESH_RATE) as self.sub:
                        for message in self.sub:
                            if self._terminate:
                                self.__listening = False
                                return
                            data = {
                                &#34;senderID&#34;: message[&#34;from&#34;],
                                &#34;data&#34;: _decode_base64_url(message[&#34;data&#34;]),
                            }

                            Thread(
                                target=self.eventhandler,
                                args=(data,),
                                name=&#34;ipfs_api.PubsubListener-eventhandler&#34;
                            ).start()
                else:
                    with http_client.pubsub.subscribe_old(self.topic) as self.sub:
                        for message in self.sub:
                            if self._terminate:
                                self.__listening = False
                                return
                            data = str(base64.b64decode(
                                str(message).split(&#39;\&#39;&#39;)[7]), &#34;utf-8&#34;)
                            Thread(
                                target=self.eventhandler,
                                args=(data,),
                                name=&#34;ipfs_api.PubsubListener-eventhandler&#34;
                            ).start()
            except:
                pass
                # print(f&#34;IPFS API Pubsub: restarting sub {self.topic}&#34;)
        self.__listening = False

    def listen(self):
        self._terminate = False
        self.listener_thread = Thread(
            target=self._listen, args=(), name=&#34;ipfs_api.PubsubListener&#34;)
        self.listener_thread.start()

    def terminate(self, wait=False):
        &#34;&#34;&#34;Stop this PubSub subscription, stop listening for data.
        May let one more pubsub message through
        Takes up to self._REFRESH_RATE seconds to complete.

        Args:
            wait (bool): whether or not this function should block until all
                activity has been stopped and resources have been cleaned up

        &#34;&#34;&#34;
        self._terminate = True
        if self.sub:
            self.sub.close()
        if wait:
            self.listener_thread.join()


def pubsub_publish(topic, data):
    &#34;&#34;&#34;Publishes te specified data to the specified IPFS-PubSub topic.
    Args:
        topic (str): the name of the IPFS PubSub topic to publish to
        data (str/bytearray): either the filepath of a file whose
            content should be published to the pubsub topic,
            or the raw data to be published as a string or bytearray.
            When using an older version of IPFS &lt; v0.11.0 however,
            only plain data as a string is accepted.
    &#34;&#34;&#34;
    if int(http_client.version()[&#34;Version&#34;].split(&#34;.&#34;)[1]) &lt; 11:
        return http_client.pubsub.publish_old(topic, data)

    if isinstance(data, str) and not os.path.exists(data):
        data = data.encode()
    if isinstance(data, bytes) or isinstance(data, bytearray):
        # Use an in-memory BytesIO object instead of a temporary file
        with BytesIO(data) as data_stream:
            # Call _publish with the BytesIO object
            http_client.pubsub.publish(topic, data_stream)
    else:
        http_client.pubsub.publish(topic, data)


def pubsub_subscribe(topic, eventhandler):
    &#34;&#34;&#34;
    Listens to the specified IPFS PubSub topic, calling the eventhandler
    whenever a message is received, passing the message data and its sender
    to the eventhandler.
    Args:
        topic (str): the name of the IPFS PubSub topic to publish to
        eventhandler (function): the function to be executed whenever a message is received.
                            The eventhandler parameter is a dict with the keys &#39;data&#39; and &#39;senderID&#39;,
                            except when using an older version of IPFS &lt; v0.11.0,
                            in which case only the message is passed as a string.
    Returns:
        PubsubListener: listener object which can  be terminated with the .terminate() method (and restarted with the .listen() method)
    &#34;&#34;&#34;
    return PubsubListener(topic, eventhandler)


def pubsub_peers(topic: str):
    &#34;&#34;&#34;Looks up what IPFS nodes we are connected to who are listening on the given topic.
    Returns:
        list: peers we are connected to on the specified pubsub topic
    &#34;&#34;&#34;
    return http_client.pubsub.peers(topic=_encode_base64_url(topic.encode()))[&#34;Strings&#34;]


def _decode_base64_url(data: str):
    &#34;&#34;&#34;Performs the URL-Safe multibase decoding required by some functions (since IFPS v0.11.0) on strings&#34;&#34;&#34;
    if isinstance(data, bytes):
        data = data.decode()
    data = str(data)[1:].encode()
    missing_padding = len(data) % 4
    if missing_padding:
        data += b&#39;=&#39; * (4 - missing_padding)
    return urlsafe_b64decode(data)


def _encode_base64_url(data: bytearray):
    &#34;&#34;&#34;Performs the URL-Safe multibase encoding required by some functions (since IFPS v0.11.0) on strings&#34;&#34;&#34;
    if isinstance(data, str):
        data = data.encode()
    data = urlsafe_b64encode(data)
    while data[-1] == 61 and data[-1]:
        data = data[:-1]
    data = b&#39;u&#39; + data
    return data


def wait_till_ipfs_is_running(timeout_sec=None):
    &#34;&#34;&#34;Waits till it can connect to the local IPFS daemon&#39;s HTTP-interface.
    Args:
        timeout_sec (int): maximum time to wait for. If this duration is,
                            exceeded, a TimeoutError is raised.
    &#34;&#34;&#34;
    count = 0
    while True:
        try:
            if is_ipfs_running():
                return
        except ipfshttpclient.exceptions.ConnectionError as error:
            pass
        time.sleep(1)
        count += 1
        if timeout_sec and count == timeout_sec:
            raise TimeoutError()


def try_run_ipfs():
    &#34;&#34;&#34;Tries to use the IPFS CLI to run the local IPFS daemon with PubSub,
    like manually executing `ipfs daemon --enable-pubsub-experiment`
    &#34;&#34;&#34;
    from ipfs_cli import try_run_ipfs as _try_run_ipfs
    _try_run_ipfs()


if LIBERROR:    # if not all modules needed for the ipfs_http_client library were loaded
    print(&#34;Falling back to IPFS CLI because our HTTP client isn&#39;t working;\nNot all modules required by the http-connection could be loaded.&#34;)
    from ipfs_cli import *</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ipfs_api.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload a file or a directory to IPFS, returning its CID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the file or directroy to publish</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the IPFS content ID (CID) of the published file/directory</dd>
</dl></div>
</dd>
<dt id="ipfs_api.predict_cid"><code class="name flex">
<span>def <span class="ident">predict_cid</span></span>(<span>path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the CID a file or directory would have if it were to be published on
IPFS, without actually publishing it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the file or directroy to publish</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the IPFS content ID (CID) the file/directory would have
if published</dd>
</dl></div>
</dd>
<dt id="ipfs_api.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>cid, path='.')</span>
</code></dt>
<dd>
<div class="desc"><p>Get the specified IPFS content, saving it to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (cid) of the resource to get</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) the path (directory or filepath) of the saved file</dd>
</dl></div>
</dd>
<dt id="ipfs_api.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>cid)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the textual content of the specified IPFS resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (CID) of the resource to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the content of the specified IPFS resource as text</dd>
</dl></div>
</dd>
<dt id="ipfs_api.pin"><code class="name flex">
<span>def <span class="ident">pin</span></span>(<span>cid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure the specified IPFS resource remains available on this IPFS node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (CID) of the resource to pin</dd>
</dl></div>
</dd>
<dt id="ipfs_api.unpin"><code class="name flex">
<span>def <span class="ident">unpin</span></span>(<span>cid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Allow a pinned IPFS resource to be garbage-collected and removed on this IPFS node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (CID) of the resource to unpin</dd>
</dl></div>
</dd>
<dt id="ipfs_api.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>cid: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove content with the given CID from this IPFS node's storage.
Note: removes all unpinned content from this IPFS node's storage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (CID) of the resource to unpin</dd>
</dl></div>
</dd>
<dt id="ipfs_api.pins"><code class="name flex">
<span>def <span class="ident">pins</span></span>(<span>cids_only: bool = False, cache_age_s: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the CIDs of files we have pinned on IPFS</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cids_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, returns a plain list of IPFS CIDs
otherwise, returns a list of dicts of CIDs and their pinning type</dd>
<dt><strong><code>cache_age_s</code></strong> :&ensp;<code>int</code></dt>
<dd>getting the of pins from IPFS can take several
seconds. IPFS_API therefore caches each result. If the age of the
cache is less than this parameter, the cacheed result is returned,
otherwise the slow process of getting the latest list of pins is
used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list(): a list of the CIDs of pinned objects. The list element type
depends on the cids_only parameter (see above)</p></div>
</dd>
<dt id="ipfs_api.create_ipns_record"><code class="name flex">
<span>def <span class="ident">create_ipns_record</span></span>(<span>name: str, type: str = 'rsa', size: int = 2048)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an IPNS record (eqv. IPNS key).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the record/key (in the scope of this IPFS node)</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>the cryptographic algorithm behind this key's security</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>the length of the key</dd>
</dl></div>
</dd>
<dt id="ipfs_api.update_ipns_record_from_cid"><code class="name flex">
<span>def <span class="ident">update_ipns_record_from_cid</span></span>(<span>record_name: str, cid: str, ttl: str = '24h', lifetime: str = '24h', **kwargs: ipfshttpclient2.client.base.CommonArgs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign IPFS content to an IPNS record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>record_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the IPNS record (IPNS key) to be updated</dd>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS content ID (CID) of the content to assign to the IPNS record</dd>
<dt><strong><code>ttl</code></strong> :&ensp;<code>str</code></dt>
<dd>Time duration this record should be cached for.
Uses the same syntax as the lifetime option.
(caution: experimental).</dd>
<dt><strong><code>lifetime</code></strong> :&ensp;<code>str</code></dt>
<dd>Time duration that the record will be valid for.
Default: 24h.</dd>
</dl></div>
</dd>
<dt id="ipfs_api.update_ipns_record"><code class="name flex">
<span>def <span class="ident">update_ipns_record</span></span>(<span>name: str, path, ttl: str = '24h', lifetime: str = '24h')</span>
</code></dt>
<dd>
<div class="desc"><p>Publish a file to IPFS and assign it to an IPNS record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>record_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the IPNS record (IPNS key) to be updated</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the file to assign to the IPNS record</dd>
<dt><strong><code>ttl</code></strong> :&ensp;<code>str</code></dt>
<dd>Time duration this record should be cached for.
Uses the same syntax as the lifetime option.
(caution: experimental).</dd>
<dt><strong><code>lifetime</code></strong> :&ensp;<code>str</code></dt>
<dd>Time duration that the record will be valid for.
Default: 24h.</dd>
</dl></div>
</dd>
<dt id="ipfs_api.resolve_ipns_key"><code class="name flex">
<span>def <span class="ident">resolve_ipns_key</span></span>(<span>ipns_key, nocache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the IPFS CID of the given IPNS record (IPNS key)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ipns_key</code></strong></dt>
<dd>the key of the IPNS record to lookup</dd>
<dt><strong><code>nocache</code></strong></dt>
<dd>whether or not to ignore this IPFS nodes cached memory of IPNS keys</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the IPFS CID associated with the IPNS key</dd>
</dl></div>
</dd>
<dt id="ipfs_api.download_ipns_record"><code class="name flex">
<span>def <span class="ident">download_ipns_record</span></span>(<span>ipns_key, path='', nocache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the specified IPFS content, saving it to a file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ipns_key</code></strong> :&ensp;<code>str</code></dt>
<dd>the key of the IPNS record to get</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) the path (directory or filepath) of the saved file</dd>
<dt><strong><code>nocache</code></strong></dt>
<dd>whether or not to ignore this IPFS nodes cached memory of IPNS keys</dd>
</dl></div>
</dd>
<dt id="ipfs_api.read_ipns_record"><code class="name flex">
<span>def <span class="ident">read_ipns_record</span></span>(<span>ipns_key, nocache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the textual content of the specified IPFS resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ipns_key</code></strong> :&ensp;<code>str</code></dt>
<dd>the key of the IPNS record to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the content of the specified IPFS resource as text</dd>
</dl></div>
</dd>
<dt id="ipfs_api.get_ipns_record_validity"><code class="name flex">
<span>def <span class="ident">get_ipns_record_validity</span></span>(<span>ipns_key)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the time at which the given IPNS record expires.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ipns_key</code></strong> :&ensp;<code>str</code></dt>
<dd>the key of the IPNS record to look up</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>datetime</code></dt>
<dd>the time at which the given IPNS record expires</dd>
</dl></div>
</dd>
<dt id="ipfs_api.my_id"><code class="name flex">
<span>def <span class="ident">my_id</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this IPFS node's peer ID.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the peer ID of this node</dd>
</dl></div>
</dd>
<dt id="ipfs_api.is_ipfs_running"><code class="name flex">
<span>def <span class="ident">is_ipfs_running</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether or not the IPFS daemon is currently running.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether or not the IPFS daemon is currently running</dd>
</dl></div>
</dd>
<dt id="ipfs_api.my_multiaddrs"><code class="name flex">
<span>def <span class="ident">my_multiaddrs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns this IPFS node's peer ID.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the peer ID of this node</dd>
</dl></div>
</dd>
<dt id="ipfs_api.list_peers"><code class="name flex">
<span>def <span class="ident">list_peers</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the IPFS multiaddresses of the other nodes
this node is connected to.</p>
<h2 id="returns">Returns</h2>
<p>list(str): a list of the IPFS multiaddresses of the other nodes
this node is connected to</p></div>
</dd>
<dt id="ipfs_api.list_peer_multiaddrs"><code class="name flex">
<span>def <span class="ident">list_peer_multiaddrs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ipfs_api.get_peer_multiaddrs"><code class="name flex">
<span>def <span class="ident">get_peer_multiaddrs</span></span>(<span>peer_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the multiaddresses (without the IPFS CID) via which we can reach
the specified peer.
Append /p2p/PEER_ID to these multiaddress parts to turn them into complete
multiaddresses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS ID of the peer to lookup</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list(str): the multiaddresses (without the IPFS CID) via which we can
reach the given peer</p></div>
</dd>
<dt id="ipfs_api.connect_to_peer"><code class="name flex">
<span>def <span class="ident">connect_to_peer</span></span>(<span>multiaddr)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to connect to a peer given its multiaddress.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>success</dd>
</dl></div>
</dd>
<dt id="ipfs_api.find_peer"><code class="name flex">
<span>def <span class="ident">find_peer</span></span>(<span>peer_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to connect to the specified IPFS node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS peer ID of the node to connect to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the multiaddress of the connected node</dd>
</dl></div>
</dd>
<dt id="ipfs_api.is_peer_connected"><code class="name flex">
<span>def <span class="ident">is_peer_connected</span></span>(<span>peer_id, ping_count=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests the connection to the given IPFS peer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS ID of the peer to test</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>(optional, default 1) the number of pings to send</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether or not the peer is connected</dd>
</dl></div>
</dd>
<dt id="ipfs_api.find_providers"><code class="name flex">
<span>def <span class="ident">find_providers</span></span>(<span>cid)</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup/find out which IPFS nodes provide the file with the given CID
(including onesself).
E.g. to check if this computer hosts a file with a certain CID:
def DoWeHaveFile(cid:str):
ipfs_api.my_id() in ipfs_api.find_providers(cid)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cid</code></strong> :&ensp;<code>str</code></dt>
<dd>cid (str): the IPFS content ID (CID) of the resource to look up</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>the peer IDs of the IPFS nodes who provide the file</dd>
</dl></div>
</dd>
<dt id="ipfs_api.create_tcp_listening_connection"><code class="name flex">
<span>def <span class="ident">create_tcp_listening_connection</span></span>(<span>name: str, port: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a listener TCP connection for IPFS' libp2p stream-mounting (port-forwarding).
TCP traffic coming from another peer via this connection is forwarded
to the specified port on localhost.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the connection (starts with /x/)</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the local TCP port number to forward incoming traffic to</dd>
</dl></div>
</dd>
<dt id="ipfs_api.create_tcp_sending_connection"><code class="name flex">
<span>def <span class="ident">create_tcp_sending_connection</span></span>(<span>name: str, port, peerID)</span>
</code></dt>
<dd>
<div class="desc"><p>Open a sending TCP connection for IPFS' libp2p stream-mounting (port-forwarding).
TCP traffic sent to the specified port on localhost will be fowarded
to the specified peer via this connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the connection (starts with /x/)</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the local TCP port number from which to forward traffic</dd>
</dl></div>
</dd>
<dt id="ipfs_api.close_all_tcp_connections"><code class="name flex">
<span>def <span class="ident">close_all_tcp_connections</span></span>(<span>listeners_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Close all libp2p stream-mounting (IPFS port-forwarding) connections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>listeners_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>if set to True, only listening connections are closed</dd>
</dl></div>
</dd>
<dt id="ipfs_api.close_tcp_sending_connection"><code class="name flex">
<span>def <span class="ident">close_tcp_sending_connection</span></span>(<span>name: str = None, port: str = None, peer_id: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Close specific sending libp2p stream-mounting (IPFS port-forwarding) connections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the connection to close</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>str</code></dt>
<dd>the local forwarded TCP port of the connection to close</dd>
<dt><strong><code>peer_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the target peer_id of the connection to close</dd>
</dl></div>
</dd>
<dt id="ipfs_api.close_tcp_listening_connection"><code class="name flex">
<span>def <span class="ident">close_tcp_listening_connection</span></span>(<span>name: str = None, port: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Close specific listening libp2p stream-mounting (IPFS port-forwarding) connections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the connection to close</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>str</code></dt>
<dd>the local listening TCP port of the connection to close</dd>
</dl></div>
</dd>
<dt id="ipfs_api.check_peer_connection"><code class="name flex">
<span>def <span class="ident">check_peer_connection</span></span>(<span>id, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Try to connect to the specified peer, and stores its multiaddresses in ipfs_lns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>the IPFS PeerID or the ipfs_lns name
of the computer to connect to</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>(optional) the human readable name of the computer to connect to (not critical, you can put in whatever you like)</dd>
</dl></div>
</dd>
<dt id="ipfs_api.pubsub_publish"><code class="name flex">
<span>def <span class="ident">pubsub_publish</span></span>(<span>topic, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Publishes te specified data to the specified IPFS-PubSub topic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>topic</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the IPFS PubSub topic to publish to</dd>
</dl>
<p>data (str/bytearray): either the filepath of a file whose
content should be published to the pubsub topic,
or the raw data to be published as a string or bytearray.
When using an older version of IPFS &lt; v0.11.0 however,
only plain data as a string is accepted.</p></div>
</dd>
<dt id="ipfs_api.pubsub_subscribe"><code class="name flex">
<span>def <span class="ident">pubsub_subscribe</span></span>(<span>topic, eventhandler)</span>
</code></dt>
<dd>
<div class="desc"><p>Listens to the specified IPFS PubSub topic, calling the eventhandler
whenever a message is received, passing the message data and its sender
to the eventhandler.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>topic</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the IPFS PubSub topic to publish to</dd>
<dt><strong><code>eventhandler</code></strong> :&ensp;<code>function</code></dt>
<dd>the function to be executed whenever a message is received.
The eventhandler parameter is a dict with the keys 'data' and 'senderID',
except when using an older version of IPFS &lt; v0.11.0,
in which case only the message is passed as a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ipfs_api.PubsubListener" href="#ipfs_api.PubsubListener">PubsubListener</a></code></dt>
<dd>listener object which can
be terminated with the .terminate() method (and restarted with the .listen() method)</dd>
</dl></div>
</dd>
<dt id="ipfs_api.pubsub_peers"><code class="name flex">
<span>def <span class="ident">pubsub_peers</span></span>(<span>topic: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up what IPFS nodes we are connected to who are listening on the given topic.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>peers we are connected to on the specified pubsub topic</dd>
</dl></div>
</dd>
<dt id="ipfs_api.wait_till_ipfs_is_running"><code class="name flex">
<span>def <span class="ident">wait_till_ipfs_is_running</span></span>(<span>timeout_sec=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits till it can connect to the local IPFS daemon's HTTP-interface.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout_sec</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum time to wait for. If this duration is,
exceeded, a TimeoutError is raised.</dd>
</dl></div>
</dd>
<dt id="ipfs_api.try_run_ipfs"><code class="name flex">
<span>def <span class="ident">try_run_ipfs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries to use the IPFS CLI to run the local IPFS daemon with PubSub,
like manually executing <code>ipfs daemon --enable-pubsub-experiment</code></p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ipfs_api.PubsubListener"><code class="flex name class">
<span>class <span class="ident">PubsubListener</span></span>
<span>(</span><span>topic, eventhandler)</span>
</code></dt>
<dd>
<div class="desc"><p>Listener object for PubSub subscriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubsubListener():
    &#34;&#34;&#34;Listener object for PubSub subscriptions.&#34;&#34;&#34;
    _terminate = False
    __listening = False
    sub = None
    _REFRESH_RATE = 5  # seconds. How often the pubsub HTTP listener ist restarted, also the maximum duration termination can take

    def __init__(self, topic, eventhandler):
        self.topic = topic
        self.eventhandler = eventhandler
        self.listen()

    def _listen(self):
        if self.__listening:
            return
        self.__listening = True
        &#34;&#34;&#34;blocks the calling thread&#34;&#34;&#34;
        while not self._terminate:
            try:
                if int(http_client.version()[&#34;Version&#34;].split(&#34;.&#34;)[1]) &gt;= 11:
                    with http_client.pubsub.subscribe(self.topic, timeout=self._REFRESH_RATE) as self.sub:
                        for message in self.sub:
                            if self._terminate:
                                self.__listening = False
                                return
                            data = {
                                &#34;senderID&#34;: message[&#34;from&#34;],
                                &#34;data&#34;: _decode_base64_url(message[&#34;data&#34;]),
                            }

                            Thread(
                                target=self.eventhandler,
                                args=(data,),
                                name=&#34;ipfs_api.PubsubListener-eventhandler&#34;
                            ).start()
                else:
                    with http_client.pubsub.subscribe_old(self.topic) as self.sub:
                        for message in self.sub:
                            if self._terminate:
                                self.__listening = False
                                return
                            data = str(base64.b64decode(
                                str(message).split(&#39;\&#39;&#39;)[7]), &#34;utf-8&#34;)
                            Thread(
                                target=self.eventhandler,
                                args=(data,),
                                name=&#34;ipfs_api.PubsubListener-eventhandler&#34;
                            ).start()
            except:
                pass
                # print(f&#34;IPFS API Pubsub: restarting sub {self.topic}&#34;)
        self.__listening = False

    def listen(self):
        self._terminate = False
        self.listener_thread = Thread(
            target=self._listen, args=(), name=&#34;ipfs_api.PubsubListener&#34;)
        self.listener_thread.start()

    def terminate(self, wait=False):
        &#34;&#34;&#34;Stop this PubSub subscription, stop listening for data.
        May let one more pubsub message through
        Takes up to self._REFRESH_RATE seconds to complete.

        Args:
            wait (bool): whether or not this function should block until all
                activity has been stopped and resources have been cleaned up

        &#34;&#34;&#34;
        self._terminate = True
        if self.sub:
            self.sub.close()
        if wait:
            self.listener_thread.join()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ipfs_api.PubsubListener.listen"><code class="name flex">
<span>def <span class="ident">listen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ipfs_api.PubsubListener.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>self, wait=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop this PubSub subscription, stop listening for data.
May let one more pubsub message through
Takes up to self._REFRESH_RATE seconds to complete.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not this function should block until all
activity has been stopped and resources have been cleaned up</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ipfs_api.publish" href="#ipfs_api.publish">publish</a></code></li>
<li><code><a title="ipfs_api.predict_cid" href="#ipfs_api.predict_cid">predict_cid</a></code></li>
<li><code><a title="ipfs_api.download" href="#ipfs_api.download">download</a></code></li>
<li><code><a title="ipfs_api.read" href="#ipfs_api.read">read</a></code></li>
<li><code><a title="ipfs_api.pin" href="#ipfs_api.pin">pin</a></code></li>
<li><code><a title="ipfs_api.unpin" href="#ipfs_api.unpin">unpin</a></code></li>
<li><code><a title="ipfs_api.remove" href="#ipfs_api.remove">remove</a></code></li>
<li><code><a title="ipfs_api.pins" href="#ipfs_api.pins">pins</a></code></li>
<li><code><a title="ipfs_api.create_ipns_record" href="#ipfs_api.create_ipns_record">create_ipns_record</a></code></li>
<li><code><a title="ipfs_api.update_ipns_record_from_cid" href="#ipfs_api.update_ipns_record_from_cid">update_ipns_record_from_cid</a></code></li>
<li><code><a title="ipfs_api.update_ipns_record" href="#ipfs_api.update_ipns_record">update_ipns_record</a></code></li>
<li><code><a title="ipfs_api.resolve_ipns_key" href="#ipfs_api.resolve_ipns_key">resolve_ipns_key</a></code></li>
<li><code><a title="ipfs_api.download_ipns_record" href="#ipfs_api.download_ipns_record">download_ipns_record</a></code></li>
<li><code><a title="ipfs_api.read_ipns_record" href="#ipfs_api.read_ipns_record">read_ipns_record</a></code></li>
<li><code><a title="ipfs_api.get_ipns_record_validity" href="#ipfs_api.get_ipns_record_validity">get_ipns_record_validity</a></code></li>
<li><code><a title="ipfs_api.my_id" href="#ipfs_api.my_id">my_id</a></code></li>
<li><code><a title="ipfs_api.is_ipfs_running" href="#ipfs_api.is_ipfs_running">is_ipfs_running</a></code></li>
<li><code><a title="ipfs_api.my_multiaddrs" href="#ipfs_api.my_multiaddrs">my_multiaddrs</a></code></li>
<li><code><a title="ipfs_api.list_peers" href="#ipfs_api.list_peers">list_peers</a></code></li>
<li><code><a title="ipfs_api.list_peer_multiaddrs" href="#ipfs_api.list_peer_multiaddrs">list_peer_multiaddrs</a></code></li>
<li><code><a title="ipfs_api.get_peer_multiaddrs" href="#ipfs_api.get_peer_multiaddrs">get_peer_multiaddrs</a></code></li>
<li><code><a title="ipfs_api.connect_to_peer" href="#ipfs_api.connect_to_peer">connect_to_peer</a></code></li>
<li><code><a title="ipfs_api.find_peer" href="#ipfs_api.find_peer">find_peer</a></code></li>
<li><code><a title="ipfs_api.is_peer_connected" href="#ipfs_api.is_peer_connected">is_peer_connected</a></code></li>
<li><code><a title="ipfs_api.find_providers" href="#ipfs_api.find_providers">find_providers</a></code></li>
<li><code><a title="ipfs_api.create_tcp_listening_connection" href="#ipfs_api.create_tcp_listening_connection">create_tcp_listening_connection</a></code></li>
<li><code><a title="ipfs_api.create_tcp_sending_connection" href="#ipfs_api.create_tcp_sending_connection">create_tcp_sending_connection</a></code></li>
<li><code><a title="ipfs_api.close_all_tcp_connections" href="#ipfs_api.close_all_tcp_connections">close_all_tcp_connections</a></code></li>
<li><code><a title="ipfs_api.close_tcp_sending_connection" href="#ipfs_api.close_tcp_sending_connection">close_tcp_sending_connection</a></code></li>
<li><code><a title="ipfs_api.close_tcp_listening_connection" href="#ipfs_api.close_tcp_listening_connection">close_tcp_listening_connection</a></code></li>
<li><code><a title="ipfs_api.check_peer_connection" href="#ipfs_api.check_peer_connection">check_peer_connection</a></code></li>
<li><code><a title="ipfs_api.pubsub_publish" href="#ipfs_api.pubsub_publish">pubsub_publish</a></code></li>
<li><code><a title="ipfs_api.pubsub_subscribe" href="#ipfs_api.pubsub_subscribe">pubsub_subscribe</a></code></li>
<li><code><a title="ipfs_api.pubsub_peers" href="#ipfs_api.pubsub_peers">pubsub_peers</a></code></li>
<li><code><a title="ipfs_api.wait_till_ipfs_is_running" href="#ipfs_api.wait_till_ipfs_is_running">wait_till_ipfs_is_running</a></code></li>
<li><code><a title="ipfs_api.try_run_ipfs" href="#ipfs_api.try_run_ipfs">try_run_ipfs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ipfs_api.PubsubListener" href="#ipfs_api.PubsubListener">PubsubListener</a></code></h4>
<ul class="">
<li><code><a title="ipfs_api.PubsubListener.listen" href="#ipfs_api.PubsubListener.listen">listen</a></code></li>
<li><code><a title="ipfs_api.PubsubListener.terminate" href="#ipfs_api.PubsubListener.terminate">terminate</a></code></li>
<li><code><a title="ipfs_api.PubsubListener.sub" href="#ipfs_api.PubsubListener.sub">sub</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
