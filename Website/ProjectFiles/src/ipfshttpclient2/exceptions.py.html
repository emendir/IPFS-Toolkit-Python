<html>
<head>
  <meta charset="UTF-8">
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <link rel="stylesheet" href="https://rawgithub.com/highlightjs/cdn-release/master/build/styles/atom-one-dark.min.css">
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/highlight.min.js"></script>
  <script src="https://rawgithub.com/highlightjs/cdn-release/master/build/languages/python.min.js"></script>
  <style>
    body {
      margin: 0px;
      padding: 15px;
      font-size: 12
    }
    .hljs {
      margin: -15px;
      word-wrap: break-word;
    }
    body, .hljs {
      font-family: Menlo, Consolas, DejaVu Sans Mono, monospace;
    }
    .number {
      float:left;
      text-align: right;
      display: inline-block;
      margin-right: 5px;
    }
    .ln {
      opacity: 0.5;
    }
    pre {
      tab-size:      4;
    }
  </style>
</head>
<body>
<pre><code class="py">
&quot;&quot;&quot;
The class hierarchy for exceptions is::

    builtins.Exception
     ├── builtins.Warning
     │    └── VersionMismatch
     └── Error
          ├── AddressError
          ├── EncoderError
          │    ├── EncoderMissingError
          │    ├── EncodingError
          │    └── DecodingError
          ├── CommunicationError
          │    ├── ProtocolError
          │    ├── StatusError
          │    ├── ErrorResponse
          │    │    └── PartialErrorResponse
          │    ├── ConnectionError
          │    └── TimeoutError
          └── MatcherSpecInvalidError

&quot;&quot;&quot;

import typing as ty

import multiaddr.exceptions  # type: ignore[import]


class Error(Exception):
	&quot;&quot;&quot;Base class for all exceptions in this module.&quot;&quot;&quot;
	__slots__ = ()


class AddressError(Error, multiaddr.exceptions.Error):  # type: ignore[no-any-unimported, misc]
	&quot;&quot;&quot;Raised when the provided daemon location Multiaddr does not match any
	of the supported patterns.&quot;&quot;&quot;
	__slots__ = (&quot;addr&quot;,)

	addr: ty.Union[str, bytes]
	
	def __init__(self, addr: ty.Union[str, bytes]) -&gt; None:
		self.addr = addr
		Error.__init__(self, &quot;Unsupported Multiaddr pattern: {0!r}&quot;.format(addr))


class VersionMismatch(Warning):
	&quot;&quot;&quot;Raised when daemon version is not supported by this client version.&quot;&quot;&quot;
	__slots__ = (&quot;current&quot;, &quot;minimum&quot;, &quot;maximum&quot;)

	current: ty.Sequence[int]
	minimum: ty.Sequence[int]
	maximum: ty.Sequence[int]
	
	def __init__(self, current: ty.Sequence[int], minimum: ty.Sequence[int],
	             maximum: ty.Sequence[int]) -&gt; None:
		self.current = current
		self.minimum = minimum
		self.maximum = maximum
		
		msg = &quot;Unsupported daemon version &#x27;{}&#x27; (not in range: {} ≤ … &lt; {})&quot;.format(
			&quot;.&quot;.join(map(str, current)), &quot;.&quot;.join(map(str, minimum)), &quot;.&quot;.join(map(str, maximum))
		)
		super().__init__(msg)


###############
# encoding.py #
###############
class EncoderError(Error):
	&quot;&quot;&quot;Base class for all encoding and decoding related errors.&quot;&quot;&quot;
	__slots__ = (&quot;encoder_name&quot;,)

	encoder_name: str
	
	def __init__(self, message: str, encoder_name: str) -&gt; None:
		self.encoder_name = encoder_name
		
		super().__init__(message)


class EncoderMissingError(EncoderError):
	&quot;&quot;&quot;Raised when a requested encoder class does not actually exist.&quot;&quot;&quot;
	__slots__ = ()
	
	def __init__(self, encoder_name: str) -&gt; None:
		super().__init__(&quot;Unknown encoder: &#x27;{}&#x27;&quot;.format(encoder_name), encoder_name)


class EncodingError(EncoderError):
	&quot;&quot;&quot;Raised when encoding a Python object into a byte string has failed
	due to some problem with the input data.&quot;&quot;&quot;
	__slots__ = (&quot;original&quot;,)

	original: Exception
	
	def __init__(self, encoder_name: str, original: Exception) -&gt; None:
		self.original = original
		
		super().__init__(&quot;Object encoding error: {}&quot;.format(original), encoder_name)


class DecodingError(EncoderError):
	&quot;&quot;&quot;Raised when decoding a byte string to a Python object has failed due to
	some problem with the input data.&quot;&quot;&quot;
	__slots__ = (&quot;original&quot;,)

	original: Exception
	
	def __init__(self, encoder_name: str, original: Exception) -&gt; None:
		self.original = original
		
		super().__init__(&quot;Object decoding error: {}&quot;.format(original), encoder_name)


##################
# filescanner.py #
##################

class MatcherSpecInvalidError(Error, TypeError):
	&quot;&quot;&quot;
	An attempt was made to build a matcher using matcher_from_spec, but an invalid
	specification was provided.
	&quot;&quot;&quot;

	def __init__(self, invalid_spec: ty.Any) -&gt; None:
		super().__init__(
			f&quot;Don&#x27;t know how to create a Matcher from spec {invalid_spec!r}&quot;
		)


###########
# http.py #
###########
class CommunicationError(Error):
	&quot;&quot;&quot;Base class for all network communication related errors.&quot;&quot;&quot;
	__slots__ = (&quot;original&quot;,)

	original: ty.Optional[Exception]
	
	def __init__(self, original: ty.Optional[Exception],
	             _message: ty.Optional[str] = None) -&gt; None:
		self.original = original
		
		if _message:
			msg = _message
		else:
			msg = &quot;{}: {}&quot;.format(type(original).__name__, str(original))
		super().__init__(msg)


class ProtocolError(CommunicationError):
	&quot;&quot;&quot;Raised when parsing the response from the daemon has failed.
	
	This can most likely occur if the service on the remote end isn&#x27;t in fact
	an IPFS daemon.&quot;&quot;&quot;
	__slots__ = ()


class StatusError(CommunicationError):
	&quot;&quot;&quot;Raised when the daemon responds with an error to our request.&quot;&quot;&quot;
	__slots__ = ()


class ErrorResponse(StatusError):
	&quot;&quot;&quot;Raised when the daemon has responded with an error message because the
	requested operation could not be carried out.&quot;&quot;&quot;
	__slots__ = ()
	
	def __init__(self, message: str, original: ty.Optional[Exception]) -&gt; None:
		super().__init__(original, message)


class PartialErrorResponse(ErrorResponse):
	&quot;&quot;&quot;Raised when the daemon has responded with an error message after having
	already returned some data.&quot;&quot;&quot;
	__slots__ = ()
	
	def __init__(self, message: str, original: ty.Optional[Exception] = None) -&gt; None:
		super().__init__(message, original)


class ConnectionError(CommunicationError):
	&quot;&quot;&quot;Raised when connecting to the service has failed on the socket layer.&quot;&quot;&quot;
	__slots__ = ()


class TimeoutError(CommunicationError):
	&quot;&quot;&quot;Raised when the daemon didn&#x27;t respond in time.&quot;&quot;&quot;
	__slots__ = ()

</code></pre>
<script>hljs.initHighlightingOnLoad();</script>
<script>
  setTimeout(function() {
    $(".number").css("width", "20px");
    $(".number span").attr("class", "ln hljs-subst");
    resize();
    var timer = false;
    $(window).resize(function() {
      if (timer !== false) {
        clearTimeout(timer);
      }
      timer = setTimeout(function() {
        resize();
      }, 200);
    })

  }, 100);
  function resize() {
    $("span.code").each(function(i, c) {
      var h = $(c).height();
      $(c).prev().height(h);
    });
  }
</script>
</body>
</html>